"""
Metadata scanning and data organization

Generated By: Claude Code (Claude Sonnet 4.5)
"""

from collections import defaultdict
from pathlib import Path
from typing import Dict, List, Set, Tuple
import logging

from ap_common import get_filtered_metadata
from ap_common.constants import (
    NORMALIZED_HEADER_CAMERA,
    NORMALIZED_HEADER_GAIN,
    NORMALIZED_HEADER_OFFSET,
    NORMALIZED_HEADER_SETTEMP,
    NORMALIZED_HEADER_READOUTMODE,
    NORMALIZED_HEADER_EXPOSURESECONDS,
    NORMALIZED_HEADER_FILTER,
    NORMALIZED_HEADER_DATE,
    TYPE_LIGHT,
    NORMALIZED_HEADER_TYPE,
)

from .config import SUPPORTED_EXTENSIONS

logger = logging.getLogger(__name__)


def scan_blink_directories(
    blink_dir: Path, quiet: bool = False
) -> List[Dict[str, str]]:
    """
    Scan blink directory tree for light frames and read their metadata.

    Args:
        blink_dir: Root blink directory to scan
        quiet: Suppress progress output

    Returns:
        List of metadata dictionaries for all light frames found
    """
    logger.debug(f"Scanning blink directory: {blink_dir}")

    # Get metadata for light frames only (exclude master calibration frames)
    patterns = [rf".*\{ext}$" for ext in SUPPORTED_EXTENSIONS]
    metadata = get_filtered_metadata(
        dirs=[str(blink_dir)],
        filters={NORMALIZED_HEADER_TYPE: TYPE_LIGHT},
        profileFromPath=True,
        patterns=patterns,
        recursive=True,
        printStatus=not quiet,
    )

    if not metadata:
        logger.warning(f"No light frames found in {blink_dir}")
        return []

    # Convert metadata dict to list of dicts
    # (get_filtered_metadata returns {filename: metadata})
    metadata_list = list(metadata.values())

    logger.debug(f"Found {len(metadata_list)} light frames")

    return metadata_list


def group_lights_by_config(
    metadata_list: List[Dict[str, str]],
) -> Dict[Tuple, List[Dict[str, str]]]:
    """
    Group light frames by unique calibration requirements.

    Groups by: camera, gain, offset, settemp, readoutmode, exposureseconds, filter, date

    Args:
        metadata_list: List of metadata dictionaries for light frames

    Returns:
        Dictionary mapping calibration config tuple to list of metadata dicts
    """
    groups: Dict[Tuple, List[Dict[str, str]]] = {}

    for metadata in metadata_list:
        # Create key from calibration-relevant fields
        key = (
            metadata.get(NORMALIZED_HEADER_CAMERA),
            metadata.get(NORMALIZED_HEADER_GAIN),
            metadata.get(NORMALIZED_HEADER_OFFSET),
            metadata.get(NORMALIZED_HEADER_SETTEMP),
            metadata.get(NORMALIZED_HEADER_READOUTMODE),
            metadata.get(NORMALIZED_HEADER_EXPOSURESECONDS),
            metadata.get(NORMALIZED_HEADER_FILTER),
            metadata.get(NORMALIZED_HEADER_DATE),
        )

        if key not in groups:
            groups[key] = []

        groups[key].append(metadata)

    logger.debug(
        f"Grouped {len(metadata_list)} lights into {len(groups)} unique configurations"
    )

    return groups


def sort_groups_by_date(
    groups: Dict[Tuple, List[Dict[str, str]]],
) -> List[Tuple[Tuple, List[Dict[str, str]]]]:
    """
    Sort configuration groups by date (oldest first).

    Critical for flexible flat matching: lights must be processed in
    chronological order so state file updates cascade correctly.

    The date is the last element (index 7) of the config key tuple.

    Args:
        groups: Dictionary mapping config tuple to list of metadata dicts

    Returns:
        List of (config_key, lights) tuples sorted by date ascending
    """

    def date_sort_key(item: Tuple[Tuple, List[Dict[str, str]]]) -> str:
        config_key = item[0]
        # Date is the last element of the config key tuple
        date_val = config_key[7] if len(config_key) > 7 else ""
        return date_val or ""

    return sorted(groups.items(), key=date_sort_key)


def collect_filters_by_date(
    groups: Dict[Tuple, List[Dict[str, str]]],
) -> Dict[str, Set[str]]:
    """
    Scan all groups and collect unique filters needed per date.

    Args:
        groups: Output from group_lights_by_config()

    Returns:
        Map: {date_str â†’ set of filter names}
        Example: {"2026-02-07": {"G", "O", "R"}}
    """
    filters_by_date: Dict[str, Set[str]] = defaultdict(set)

    for config_key, lights in groups.items():
        # config_key = (camera, gain, offset, settemp, readoutmode,
        #               exposure, filter, date)
        # Defensive: check tuple length
        if len(config_key) < 8:
            logger.debug(f"Skipping malformed config_key: {config_key}")
            continue

        date = config_key[7]
        filter_name = config_key[6]
        if date and filter_name:
            filters_by_date[date].add(filter_name)

    return dict(filters_by_date)
