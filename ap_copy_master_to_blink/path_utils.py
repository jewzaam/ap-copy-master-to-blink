"""
Path extraction and validation utilities

Generated By: Claude Code (Claude Sonnet 4.5)
"""

import re
from pathlib import Path
from typing import Dict, List, Optional, Set, Tuple
import logging

from ap_common.constants import (
    NORMALIZED_HEADER_DATE,
    NORMALIZED_HEADER_FILTER,
    NORMALIZED_HEADER_FILENAME,
)

logger = logging.getLogger(__name__)


def get_date_directory(lights_dir: Path, date_dir_pattern: str) -> Path:
    """
    Find the parent directory matching date pattern where masters should be copied.

    Searches upward from lights_dir for a directory matching date_dir_pattern.
    If no match found, returns lights_dir itself (leaf directory).

    This assumes other tools in the suite create directories following the pattern
    (e.g., DATE_YYYY-MM-DD). The pattern is configurable for flexibility.

    Args:
        lights_dir: Directory containing light frames (or parent thereof)
        date_dir_pattern: Regex pattern to match date directory

    Returns:
        Path to directory where masters should be copied
    """
    # Search upward for directory matching date pattern
    current = lights_dir
    while current.parent != current:  # Stop at filesystem root
        if re.match(date_dir_pattern, current.name):
            logger.debug(f"Found date directory: {current}")
            return current
        current = current.parent

    # No date directory found - use leaf directory
    logger.debug(
        f"No directory matching pattern '{date_dir_pattern}' found, "
        f"using leaf directory: {lights_dir}"
    )
    return lights_dir


def extract_target_from_path(light_path: Path, blink_dir: Path) -> Optional[str]:
    """
    Extract target name from blink path structure.

    Expected structure: blink_dir/TARGET/DATE/FILTER/file

    Args:
        light_path: Full path to light frame file
        blink_dir: Root blink directory

    Returns:
        Target name (first component after blink_dir), or None if not found
    """
    try:
        # Get relative path from blink_dir
        rel_path = light_path.relative_to(blink_dir)
        # First component is TARGET
        if rel_path.parts:
            return rel_path.parts[0]
    except (ValueError, IndexError):
        # Can't extract target from path
        pass

    return None


def extract_organization_metrics(
    metadata_list: List[Dict[str, str]], blink_dir: Path
) -> Tuple[Set[str], Set[str], Set[str]]:
    """
    Extract organizational metrics from metadata list.

    Args:
        metadata_list: List of metadata dictionaries for light frames
        blink_dir: Root blink directory (for target extraction)

    Returns:
        Tuple of (targets, dates, filters) sets
    """
    targets: Set[str] = set()
    dates: Set[str] = set()
    filters: Set[str] = set()

    for metadata in metadata_list:
        # Extract target from path (blink_dir/TARGET/DATE/FILTER/file)
        light_path = Path(metadata[NORMALIZED_HEADER_FILENAME])
        target = extract_target_from_path(light_path, blink_dir)
        if target:
            targets.add(target)

        # Extract date and filter from metadata
        if NORMALIZED_HEADER_DATE in metadata:
            dates.add(metadata[NORMALIZED_HEADER_DATE])
        if NORMALIZED_HEADER_FILTER in metadata:
            filters.add(metadata[NORMALIZED_HEADER_FILTER])

    return targets, dates, filters
