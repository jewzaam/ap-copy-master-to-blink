"""
Library search and matching logic for master calibration frames

Generated By: Claude Code (Claude Sonnet 4.5)
"""

from typing import Dict, List, Optional
from pathlib import Path
from datetime import datetime, timedelta
import logging

from ap_common import get_filtered_metadata
from ap_common.constants import (
    TYPE_MASTER_DARK,
    TYPE_MASTER_FLAT,
    TYPE_MASTER_BIAS,
    NORMALIZED_HEADER_TYPE,
    NORMALIZED_HEADER_CAMERA,
    NORMALIZED_HEADER_GAIN,
    NORMALIZED_HEADER_OFFSET,
    NORMALIZED_HEADER_SETTEMP,
    NORMALIZED_HEADER_READOUTMODE,
    NORMALIZED_HEADER_EXPOSURESECONDS,
    NORMALIZED_HEADER_DATE,
    NORMALIZED_HEADER_FILTER,
    NORMALIZED_HEADER_OPTIC,
    NORMALIZED_HEADER_FOCALLEN,
)

logger = logging.getLogger(__name__)


def find_matching_dark(
    library_dir: Path,
    light_metadata: Dict[str, str],
) -> Optional[Dict[str, str]]:
    """
    Find matching dark frame for a light frame.

    Priority:
    1. Exact exposure match
    2. If no exact match: Find longest dark exposure < light exposure

    Note: Caller is responsible for determining if bias is needed when
    dark exposure < light exposure.

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame

    Returns:
        Metadata dict for matching dark, or None if no match found
    """
    exposure = float(light_metadata.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1))

    # Build filter criteria (without exposure)
    filter_criteria = {
        NORMALIZED_HEADER_TYPE: TYPE_MASTER_DARK,
        NORMALIZED_HEADER_CAMERA: light_metadata.get(NORMALIZED_HEADER_CAMERA),
        NORMALIZED_HEADER_GAIN: light_metadata.get(NORMALIZED_HEADER_GAIN),
        NORMALIZED_HEADER_OFFSET: light_metadata.get(NORMALIZED_HEADER_OFFSET),
        NORMALIZED_HEADER_SETTEMP: light_metadata.get(NORMALIZED_HEADER_SETTEMP),
        NORMALIZED_HEADER_READOUTMODE: light_metadata.get(
            NORMALIZED_HEADER_READOUTMODE
        ),
    }

    # Search for all matching darks (any exposure)
    darks = get_filtered_metadata(library_dir, filter_criteria)

    if not darks:
        logger.debug(f"No matching darks found for criteria: {filter_criteria}")
        return None

    # Try exact exposure match first
    exact_matches = [
        d
        for d in darks
        if float(d.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1)) == exposure
    ]

    if exact_matches:
        if len(exact_matches) > 1:
            logger.warning(
                f"Found {len(exact_matches)} matching darks for exposure {exposure}s, "
                f"using first match"
            )
        logger.debug(f"Found exact dark exposure match: {exposure}s")
        return exact_matches[0]

    # No exact match - find longest dark exposure < light exposure
    shorter_darks = [
        d
        for d in darks
        if float(d.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1)) < exposure
    ]

    if shorter_darks:
        # Sort by exposure time and get the longest
        shorter_darks.sort(
            key=lambda d: float(d.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1)),
            reverse=True,
        )
        best_dark = shorter_darks[0]
        logger.debug(
            f"Found shorter dark exposure: {best_dark.get(NORMALIZED_HEADER_EXPOSURESECONDS)}s "
            f"for light exposure: {exposure}s"
        )
        return best_dark

    logger.debug(f"No suitable dark found for exposure {exposure}s")
    return None


def find_matching_bias(
    library_dir: Path,
    light_metadata: Dict[str, str],
) -> Optional[Dict[str, str]]:
    """
    Find matching bias frame for a light frame.

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame

    Returns:
        Metadata dict for matching bias, or None if no match found
    """
    filter_criteria = {
        NORMALIZED_HEADER_TYPE: TYPE_MASTER_BIAS,
        NORMALIZED_HEADER_CAMERA: light_metadata.get(NORMALIZED_HEADER_CAMERA),
        NORMALIZED_HEADER_GAIN: light_metadata.get(NORMALIZED_HEADER_GAIN),
        NORMALIZED_HEADER_OFFSET: light_metadata.get(NORMALIZED_HEADER_OFFSET),
        NORMALIZED_HEADER_SETTEMP: light_metadata.get(NORMALIZED_HEADER_SETTEMP),
        NORMALIZED_HEADER_READOUTMODE: light_metadata.get(
            NORMALIZED_HEADER_READOUTMODE
        ),
    }

    biases = get_filtered_metadata(library_dir, filter_criteria)

    if biases:
        if len(biases) > 1:
            logger.warning(
                f"Found {len(biases)} matching bias frames, using first match"
            )
        logger.debug(f"Found matching bias for criteria: {filter_criteria}")
        return biases[0]

    logger.debug(f"No matching bias found for criteria: {filter_criteria}")
    return None


def _parse_date(date_str: Optional[str]) -> Optional[datetime]:
    """
    Parse a date string in YYYY-MM-DD format.

    Args:
        date_str: Date string to parse

    Returns:
        datetime object, or None if parsing fails
    """
    if not date_str:
        return None
    try:
        return datetime.strptime(date_str, "%Y-%m-%d")
    except ValueError:
        return None


def find_matching_flat(
    library_dir: Path,
    light_metadata: Dict[str, str],
    flat_date_tolerance: int = 0,
) -> Optional[Dict[str, str]]:
    """
    Find matching flat frame for a light frame.

    Matching priority:
    1. Exact date match (always preferred)
    2. Older flats within tolerance (most recent date selected)
    3. Newer flats within tolerance (oldest date selected)

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame
        flat_date_tolerance: Date tolerance in days. 0 = exact match only (default).
            When > 0, flats from nearby dates will be used if exact match not found.

    Returns:
        Metadata dict for matching flat, or None if no match found
    """
    light_date_str = light_metadata.get(NORMALIZED_HEADER_DATE)
    light_date = _parse_date(light_date_str)

    # Build filter criteria without date (we'll filter date manually for tolerance)
    base_filter_criteria = {
        NORMALIZED_HEADER_TYPE: TYPE_MASTER_FLAT,
        NORMALIZED_HEADER_CAMERA: light_metadata.get(NORMALIZED_HEADER_CAMERA),
        NORMALIZED_HEADER_OPTIC: light_metadata.get(NORMALIZED_HEADER_OPTIC),
        NORMALIZED_HEADER_FILTER: light_metadata.get(NORMALIZED_HEADER_FILTER),
        NORMALIZED_HEADER_GAIN: light_metadata.get(NORMALIZED_HEADER_GAIN),
        NORMALIZED_HEADER_OFFSET: light_metadata.get(NORMALIZED_HEADER_OFFSET),
        NORMALIZED_HEADER_SETTEMP: light_metadata.get(NORMALIZED_HEADER_SETTEMP),
        NORMALIZED_HEADER_READOUTMODE: light_metadata.get(
            NORMALIZED_HEADER_READOUTMODE
        ),
        NORMALIZED_HEADER_FOCALLEN: light_metadata.get(NORMALIZED_HEADER_FOCALLEN),
    }

    # Priority 1: Try exact date match first
    exact_filter_criteria = {
        **base_filter_criteria,
        NORMALIZED_HEADER_DATE: light_date_str,
    }
    flats = get_filtered_metadata(library_dir, exact_filter_criteria)

    if flats:
        if len(flats) > 1:
            logger.warning(
                f"Found {len(flats)} matching flats for date {light_date_str} "
                f"and filter {light_metadata.get(NORMALIZED_HEADER_FILTER)}, using first match"
            )
        logger.debug(f"Found exact date match flat for date: {light_date_str}")
        return flats[0]

    # If tolerance is 0 or date parsing failed, return None
    if flat_date_tolerance <= 0 or light_date is None:
        logger.debug(
            f"No matching flat found for date: {light_date_str} "
            f"and filter: {light_metadata.get(NORMALIZED_HEADER_FILTER)}"
        )
        return None

    # Get all flats matching non-date criteria
    all_flats = get_filtered_metadata(library_dir, base_filter_criteria)

    if not all_flats:
        logger.debug(
            f"No matching flat found for filter: {light_metadata.get(NORMALIZED_HEADER_FILTER)} "
            f"(no flats match non-date criteria)"
        )
        return None

    # Calculate date bounds
    min_date = light_date - timedelta(days=flat_date_tolerance)
    max_date = light_date + timedelta(days=flat_date_tolerance)

    # Categorize flats within tolerance
    older_flats: List[Dict[str, str]] = []
    newer_flats: List[Dict[str, str]] = []

    for flat in all_flats:
        flat_date_str = flat.get(NORMALIZED_HEADER_DATE)
        flat_date = _parse_date(flat_date_str)
        if flat_date is None:
            continue

        if flat_date < light_date and flat_date >= min_date:
            older_flats.append(flat)
        elif flat_date > light_date and flat_date <= max_date:
            newer_flats.append(flat)

    # Priority 2: Select most recent older flat within tolerance
    if older_flats:
        older_flats.sort(
            key=lambda f: _parse_date(f.get(NORMALIZED_HEADER_DATE)) or datetime.min,
            reverse=True,
        )
        best_flat = older_flats[0]
        flat_date_str = best_flat.get(NORMALIZED_HEADER_DATE)
        logger.info(
            f"Found older flat within tolerance: date={flat_date_str} "
            f"for light date={light_date_str} (tolerance={flat_date_tolerance} days)"
        )
        return best_flat

    # Priority 3: Select oldest newer flat within tolerance
    if newer_flats:
        newer_flats.sort(
            key=lambda f: _parse_date(f.get(NORMALIZED_HEADER_DATE)) or datetime.max,
        )
        best_flat = newer_flats[0]
        flat_date_str = best_flat.get(NORMALIZED_HEADER_DATE)
        logger.info(
            f"Found newer flat within tolerance: date={flat_date_str} "
            f"for light date={light_date_str} (tolerance={flat_date_tolerance} days)"
        )
        return best_flat

    logger.debug(
        f"No matching flat found within tolerance={flat_date_tolerance} days "
        f"for date: {light_date_str} and filter: {light_metadata.get(NORMALIZED_HEADER_FILTER)}"
    )
    return None


def determine_required_masters(
    library_dir: Path,
    light_metadata: Dict[str, str],
    flat_date_tolerance: int = 0,
) -> Dict[str, Optional[Dict[str, str]]]:
    """
    Determine which master frames are required for a light frame.

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame
        flat_date_tolerance: Date tolerance in days for flat frame matching.
            0 = exact match only (default).

    Returns:
        Dictionary with keys:
        - TYPE_MASTER_DARK: Dark metadata dict or None
        - TYPE_MASTER_BIAS: Bias metadata dict or None
        - TYPE_MASTER_FLAT: Flat metadata dict or None
    """
    dark = find_matching_dark(library_dir, light_metadata)
    bias = None
    flat = find_matching_flat(
        library_dir, light_metadata, flat_date_tolerance=flat_date_tolerance
    )

    # Only look for bias if dark exposure != light exposure
    if dark:
        dark_exposure = float(dark.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1))
        light_exposure = float(
            light_metadata.get(NORMALIZED_HEADER_EXPOSURESECONDS, -1)
        )

        if dark_exposure < light_exposure:
            # Shorter dark - need bias
            bias = find_matching_bias(library_dir, light_metadata)
            if not bias:
                # No bias found - cannot use this dark
                logger.warning(
                    f"Found shorter dark ({dark_exposure}s) but no matching bias "
                    f"for light exposure ({light_exposure}s) - cannot use dark"
                )
                dark = None

    return {
        TYPE_MASTER_DARK: dark,
        TYPE_MASTER_BIAS: bias,
        TYPE_MASTER_FLAT: flat,
    }
