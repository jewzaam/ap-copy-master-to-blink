"""
Library search and matching logic for master calibration frames

Generated By: Claude Code (Claude Sonnet 4.5)
"""

from typing import Dict, List, Optional, Tuple
from pathlib import Path
import logging

from ap_common import get_filtered_metadata

from .config import (
    TYPE_MASTER_DARK,
    TYPE_MASTER_FLAT,
    TYPE_MASTER_BIAS,
    KEYWORD_TYPE,
    KEYWORD_CAMERA,
    KEYWORD_GAIN,
    KEYWORD_OFFSET,
    KEYWORD_SETTEMP,
    KEYWORD_READOUTMODE,
    KEYWORD_EXPOSURESECONDS,
    KEYWORD_DATE,
    KEYWORD_FILTER,
    KEYWORD_OPTIC,
    KEYWORD_FOCALLEN,
)

logger = logging.getLogger(__name__)


def find_matching_dark(
    library_dir: Path,
    light_metadata: Dict[str, str],
) -> Optional[Dict[str, str]]:
    """
    Find matching dark frame for a light frame.

    Priority:
    1. Exact exposure match
    2. If no exact match: Find longest dark exposure < light exposure
       (only if matching bias exists)

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame

    Returns:
        Metadata dict for matching dark, or None if no match found
    """
    exposure = float(light_metadata.get(KEYWORD_EXPOSURESECONDS, 0))

    # Build filter criteria (without exposure)
    filter_criteria = {
        KEYWORD_TYPE: TYPE_MASTER_DARK,
        KEYWORD_CAMERA: light_metadata.get(KEYWORD_CAMERA),
        KEYWORD_GAIN: light_metadata.get(KEYWORD_GAIN),
        KEYWORD_OFFSET: light_metadata.get(KEYWORD_OFFSET),
        KEYWORD_SETTEMP: light_metadata.get(KEYWORD_SETTEMP),
        KEYWORD_READOUTMODE: light_metadata.get(KEYWORD_READOUTMODE),
    }

    # Search for all matching darks (any exposure)
    darks = get_filtered_metadata(library_dir, filter_criteria)

    if not darks:
        logger.debug(f"No matching darks found for criteria: {filter_criteria}")
        return None

    # Try exact exposure match first
    exact_matches = [
        d for d in darks if float(d.get(KEYWORD_EXPOSURESECONDS, 0)) == exposure
    ]

    if exact_matches:
        logger.debug(f"Found exact dark exposure match: {exposure}s")
        return exact_matches[0]

    # No exact match - find longest dark exposure < light exposure
    shorter_darks = [
        d for d in darks if float(d.get(KEYWORD_EXPOSURESECONDS, 0)) < exposure
    ]

    if shorter_darks:
        # Sort by exposure time and get the longest
        shorter_darks.sort(
            key=lambda d: float(d.get(KEYWORD_EXPOSURESECONDS, 0)), reverse=True
        )
        best_dark = shorter_darks[0]
        logger.debug(
            f"Found shorter dark exposure: {best_dark.get(KEYWORD_EXPOSURESECONDS)}s "
            f"for light exposure: {exposure}s (requires bias)"
        )
        return best_dark

    logger.debug(f"No suitable dark found for exposure {exposure}s")
    return None


def find_matching_bias(
    library_dir: Path,
    light_metadata: Dict[str, str],
) -> Optional[Dict[str, str]]:
    """
    Find matching bias frame for a light frame.

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame

    Returns:
        Metadata dict for matching bias, or None if no match found
    """
    filter_criteria = {
        KEYWORD_TYPE: TYPE_MASTER_BIAS,
        KEYWORD_CAMERA: light_metadata.get(KEYWORD_CAMERA),
        KEYWORD_GAIN: light_metadata.get(KEYWORD_GAIN),
        KEYWORD_OFFSET: light_metadata.get(KEYWORD_OFFSET),
        KEYWORD_SETTEMP: light_metadata.get(KEYWORD_SETTEMP),
        KEYWORD_READOUTMODE: light_metadata.get(KEYWORD_READOUTMODE),
    }

    biases = get_filtered_metadata(library_dir, filter_criteria)

    if biases:
        logger.debug(f"Found matching bias for criteria: {filter_criteria}")
        return biases[0]

    logger.debug(f"No matching bias found for criteria: {filter_criteria}")
    return None


def find_matching_flat(
    library_dir: Path,
    light_metadata: Dict[str, str],
) -> Optional[Dict[str, str]]:
    """
    Find matching flat frame for a light frame.

    DATE must match exactly.

    TODO: Support selecting older flats when exact date match not found
    This would scan DATE subdirectories < light frame date and pick the most recent

    TODO: Support selecting newer flats when exact date match not found
    This would scan DATE subdirectories > light frame date and pick the oldest

    TODO: Add configuration option for flat date tolerance (e.g., Â±7 days)

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame

    Returns:
        Metadata dict for matching flat, or None if no match found
    """
    filter_criteria = {
        KEYWORD_TYPE: TYPE_MASTER_FLAT,
        KEYWORD_CAMERA: light_metadata.get(KEYWORD_CAMERA),
        KEYWORD_OPTIC: light_metadata.get(KEYWORD_OPTIC),
        KEYWORD_FILTER: light_metadata.get(KEYWORD_FILTER),
        KEYWORD_GAIN: light_metadata.get(KEYWORD_GAIN),
        KEYWORD_OFFSET: light_metadata.get(KEYWORD_OFFSET),
        KEYWORD_SETTEMP: light_metadata.get(KEYWORD_SETTEMP),
        KEYWORD_READOUTMODE: light_metadata.get(KEYWORD_READOUTMODE),
        KEYWORD_FOCALLEN: light_metadata.get(KEYWORD_FOCALLEN),
        KEYWORD_DATE: light_metadata.get(KEYWORD_DATE),  # Exact match required
    }

    flats = get_filtered_metadata(library_dir, filter_criteria)

    if flats:
        logger.debug(
            f"Found matching flat for date: {light_metadata.get(KEYWORD_DATE)}"
        )
        return flats[0]

    logger.debug(
        f"No matching flat found for date: {light_metadata.get(KEYWORD_DATE)} "
        f"and filter: {light_metadata.get(KEYWORD_FILTER)}"
    )
    return None


def determine_required_masters(
    library_dir: Path,
    light_metadata: Dict[str, str],
) -> Tuple[Optional[Dict], Optional[Dict], Optional[Dict]]:
    """
    Determine which master frames are required for a light frame.

    Returns tuple of (dark, bias, flat) metadata dicts.
    Any can be None if not found.

    Args:
        library_dir: Path to calibration library
        light_metadata: Metadata dictionary for light frame

    Returns:
        Tuple of (dark_metadata, bias_metadata, flat_metadata)
        Each can be None if not found
    """
    dark = find_matching_dark(library_dir, light_metadata)
    bias = None
    flat = find_matching_flat(library_dir, light_metadata)

    # Only look for bias if dark exposure != light exposure
    if dark:
        dark_exposure = float(dark.get(KEYWORD_EXPOSURESECONDS, 0))
        light_exposure = float(light_metadata.get(KEYWORD_EXPOSURESECONDS, 0))

        if dark_exposure < light_exposure:
            # Shorter dark - need bias
            bias = find_matching_bias(library_dir, light_metadata)
            if not bias:
                # No bias found - cannot use this dark
                logger.warning(
                    f"Found shorter dark ({dark_exposure}s) but no matching bias "
                    f"for light exposure ({light_exposure}s) - cannot use dark"
                )
                dark = None

    return dark, bias, flat
