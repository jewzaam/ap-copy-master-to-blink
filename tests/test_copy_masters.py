"""
Tests for copy logic

Generated By: Claude Code (Claude Sonnet 4.5)
"""

import unittest
from pathlib import Path
from unittest.mock import patch, MagicMock

from ap_copy_master_to_blink.copy_masters import (
    get_date_directory,
    scan_blink_directories,
    group_lights_by_config,
    copy_master_to_blink,
    process_blink_directory,
)
from ap_copy_master_to_blink.config import (
    KEYWORD_CAMERA,
    KEYWORD_GAIN,
    KEYWORD_OFFSET,
    KEYWORD_SETTEMP,
    KEYWORD_READOUTMODE,
    KEYWORD_EXPOSURESECONDS,
    KEYWORD_FILTER,
    KEYWORD_DATE,
)


class TestCopyMasters(unittest.TestCase):
    """Test copy logic."""

    def test_get_date_directory_from_filter_dir(self):
        """Test extracting DATE directory from FILTER directory."""
        lights_dir = Path("/blink/M31/DATE_2024-01-15/FILTER_Ha")
        result = get_date_directory(lights_dir)

        self.assertEqual(result.name, "DATE_2024-01-15")

    def test_get_date_directory_from_date_dir(self):
        """Test when already in DATE directory."""
        lights_dir = Path("/blink/M31/DATE_2024-01-15")
        result = get_date_directory(lights_dir)

        self.assertEqual(result.name, "DATE_2024-01-15")

    def test_get_date_directory_search_upward(self):
        """Test searching upward for DATE directory."""
        lights_dir = Path("/blink/M31/DATE_2024-01-15/FILTER_Ha/subdir")
        result = get_date_directory(lights_dir)

        self.assertEqual(result.name, "DATE_2024-01-15")

    @patch("ap_copy_master_to_blink.copy_masters.get_filenames")
    @patch("ap_copy_master_to_blink.copy_masters.get_metadata")
    def test_scan_blink_directories(self, mock_get_metadata, mock_get_filenames):
        """Test scanning blink directories for light frames."""
        mock_get_filenames.return_value = [
            Path("/blink/light1.fits"),
            Path("/blink/light2.fits"),
        ]
        mock_get_metadata.return_value = [
            {"filepath": "/blink/light1.fits"},
            {"filepath": "/blink/light2.fits"},
        ]

        result = scan_blink_directories(Path("/blink"))

        self.assertEqual(len(result), 2)
        mock_get_filenames.assert_called_once()
        mock_get_metadata.assert_called_once()

    def test_group_lights_by_config(self):
        """Test grouping lights by calibration configuration."""
        metadata_list = [
            {
                KEYWORD_CAMERA: "ASI2600MM",
                KEYWORD_GAIN: "100",
                KEYWORD_OFFSET: "50",
                KEYWORD_SETTEMP: "-10",
                KEYWORD_READOUTMODE: "0",
                KEYWORD_EXPOSURESECONDS: "300",
                KEYWORD_FILTER: "Ha",
                KEYWORD_DATE: "2024-01-15",
            },
            {
                KEYWORD_CAMERA: "ASI2600MM",
                KEYWORD_GAIN: "100",
                KEYWORD_OFFSET: "50",
                KEYWORD_SETTEMP: "-10",
                KEYWORD_READOUTMODE: "0",
                KEYWORD_EXPOSURESECONDS: "300",
                KEYWORD_FILTER: "Ha",
                KEYWORD_DATE: "2024-01-15",
            },
            {
                KEYWORD_CAMERA: "ASI2600MM",
                KEYWORD_GAIN: "100",
                KEYWORD_OFFSET: "50",
                KEYWORD_SETTEMP: "-10",
                KEYWORD_READOUTMODE: "0",
                KEYWORD_EXPOSURESECONDS: "300",
                KEYWORD_FILTER: "OIII",  # Different filter
                KEYWORD_DATE: "2024-01-15",
            },
        ]

        groups = group_lights_by_config(metadata_list)

        # Should have 2 groups (Ha and OIII)
        self.assertEqual(len(groups), 2)

        # Ha group should have 2 lights
        ha_groups = [g for g in groups.values() if len(g) == 2]
        self.assertEqual(len(ha_groups), 1)

        # OIII group should have 1 light
        oiii_groups = [g for g in groups.values() if len(g) == 1]
        self.assertEqual(len(oiii_groups), 1)

    @patch("ap_copy_master_to_blink.copy_masters.copy_file")
    def test_copy_master_to_blink_new_file(self, mock_copy_file):
        """Test copying master when file doesn't exist."""
        master_metadata = {"filepath": "/library/dark.xisf"}
        dest_dir = Path("/blink/DATE_2024-01-15")

        with patch("pathlib.Path.exists", return_value=False):
            result = copy_master_to_blink(master_metadata, dest_dir, dry_run=False)

        self.assertTrue(result)
        mock_copy_file.assert_called_once()

    def test_copy_master_to_blink_existing_file(self):
        """Test skipping copy when file already exists."""
        master_metadata = {"filepath": "/library/dark.xisf"}
        dest_dir = Path("/blink/DATE_2024-01-15")

        with patch("pathlib.Path.exists", return_value=True):
            result = copy_master_to_blink(master_metadata, dest_dir, dry_run=False)

        self.assertFalse(result)

    def test_copy_master_to_blink_dry_run(self):
        """Test dry-run mode doesn't copy files."""
        master_metadata = {"filepath": "/library/dark.xisf"}
        dest_dir = Path("/blink/DATE_2024-01-15")

        with patch("pathlib.Path.exists", return_value=False):
            with patch("ap_copy_master_to_blink.copy_masters.copy_file") as mock_copy:
                result = copy_master_to_blink(master_metadata, dest_dir, dry_run=True)

        self.assertTrue(result)
        mock_copy.assert_not_called()

    @patch("ap_copy_master_to_blink.copy_masters.scan_blink_directories")
    @patch("ap_copy_master_to_blink.copy_masters.determine_required_masters")
    @patch("ap_copy_master_to_blink.copy_masters.copy_master_to_blink")
    def test_process_blink_directory_no_lights(
        self, mock_copy, mock_determine, mock_scan
    ):
        """Test processing when no lights found."""
        mock_scan.return_value = []

        stats = process_blink_directory(Path("/library"), Path("/blink"), dry_run=False)

        self.assertEqual(stats["configs_processed"], 0)
        mock_determine.assert_not_called()
        mock_copy.assert_not_called()

    @patch("ap_copy_master_to_blink.copy_masters.scan_blink_directories")
    @patch("ap_copy_master_to_blink.copy_masters.group_lights_by_config")
    @patch("ap_copy_master_to_blink.copy_masters.determine_required_masters")
    @patch("ap_copy_master_to_blink.copy_masters.get_date_directory")
    @patch("ap_copy_master_to_blink.copy_masters.copy_master_to_blink")
    def test_process_blink_directory_with_all_masters(
        self, mock_copy, mock_get_date, mock_determine, mock_group, mock_scan
    ):
        """Test processing with all master types found."""
        # Mock light metadata
        light_metadata = {
            "filepath": "/blink/M31/DATE_2024-01-15/FILTER_Ha/light.fits",
            KEYWORD_CAMERA: "ASI2600MM",
            KEYWORD_GAIN: "100",
            KEYWORD_OFFSET: "50",
            KEYWORD_SETTEMP: "-10",
            KEYWORD_READOUTMODE: "0",
            KEYWORD_EXPOSURESECONDS: "300",
            KEYWORD_FILTER: "Ha",
            KEYWORD_DATE: "2024-01-15",
        }

        mock_scan.return_value = [light_metadata]
        mock_group.return_value = {("config_key",): [light_metadata]}
        mock_get_date.return_value = Path("/blink/M31/DATE_2024-01-15")

        # Mock all masters found
        dark = {"filepath": "/library/dark.xisf"}
        bias = {"filepath": "/library/bias.xisf"}
        flat = {"filepath": "/library/flat.xisf"}
        mock_determine.return_value = (dark, bias, flat)

        # Mock successful copy
        mock_copy.return_value = True

        stats = process_blink_directory(Path("/library"), Path("/blink"), dry_run=False)

        self.assertEqual(stats["configs_processed"], 1)
        self.assertEqual(stats["darks_copied"], 1)
        self.assertEqual(stats["biases_copied"], 1)
        self.assertEqual(stats["flats_copied"], 1)
        self.assertEqual(stats["darks_missing"], 0)
        self.assertEqual(stats["flats_missing"], 0)

    @patch("ap_copy_master_to_blink.copy_masters.scan_blink_directories")
    @patch("ap_copy_master_to_blink.copy_masters.group_lights_by_config")
    @patch("ap_copy_master_to_blink.copy_masters.determine_required_masters")
    @patch("ap_copy_master_to_blink.copy_masters.get_date_directory")
    @patch("ap_copy_master_to_blink.copy_masters.copy_master_to_blink")
    def test_process_blink_directory_missing_masters(
        self, mock_copy, mock_get_date, mock_determine, mock_group, mock_scan
    ):
        """Test processing with missing masters."""
        # Mock light metadata
        light_metadata = {
            "filepath": "/blink/M31/DATE_2024-01-15/FILTER_Ha/light.fits",
            KEYWORD_CAMERA: "ASI2600MM",
            KEYWORD_GAIN: "100",
            KEYWORD_OFFSET: "50",
            KEYWORD_SETTEMP: "-10",
            KEYWORD_READOUTMODE: "0",
            KEYWORD_EXPOSURESECONDS: "300",
            KEYWORD_FILTER: "Ha",
            KEYWORD_DATE: "2024-01-15",
        }

        mock_scan.return_value = [light_metadata]
        mock_group.return_value = {("config_key",): [light_metadata]}
        mock_get_date.return_value = Path("/blink/M31/DATE_2024-01-15")

        # Mock no masters found
        mock_determine.return_value = (None, None, None)

        stats = process_blink_directory(Path("/library"), Path("/blink"), dry_run=False)

        self.assertEqual(stats["configs_processed"], 1)
        self.assertEqual(stats["darks_copied"], 0)
        self.assertEqual(stats["biases_copied"], 0)
        self.assertEqual(stats["flats_copied"], 0)
        self.assertEqual(stats["darks_missing"], 1)
        self.assertEqual(stats["flats_missing"], 1)


if __name__ == "__main__":
    unittest.main()
