"""
Tests for matching logic

Generated By: Claude Code (Claude Sonnet 4.5)
"""

import unittest
from pathlib import Path
from unittest.mock import patch, MagicMock

from ap_common.constants import (
    NORMALIZED_HEADER_CAMERA,
    NORMALIZED_HEADER_GAIN,
    NORMALIZED_HEADER_OFFSET,
    NORMALIZED_HEADER_SETTEMP,
    NORMALIZED_HEADER_READOUTMODE,
    NORMALIZED_HEADER_EXPOSURESECONDS,
    NORMALIZED_HEADER_DATE,
    NORMALIZED_HEADER_FILTER,
    NORMALIZED_HEADER_OPTIC,
    NORMALIZED_HEADER_FOCALLEN,
    TYPE_MASTER_DARK,
    TYPE_MASTER_BIAS,
    TYPE_MASTER_FLAT,
)

from ap_copy_master_to_blink.matching import (
    find_matching_dark,
    find_matching_bias,
    find_matching_flat,
    determine_required_masters,
)


class TestMatching(unittest.TestCase):
    """Test matching logic."""

    def setUp(self):
        """Set up test fixtures."""
        self.library_dir = Path("/test/library")
        self.light_metadata = {
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: "100",
            NORMALIZED_HEADER_OFFSET: "50",
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILTER: "Ha",
            NORMALIZED_HEADER_DATE: "2024-01-15",
            NORMALIZED_HEADER_OPTIC: "RedCat51",
            NORMALIZED_HEADER_FOCALLEN: "250",
        }

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_find_matching_dark_exact_exposure(self, mock_get_metadata):
        """Test finding dark with exact exposure match."""
        mock_get_metadata.return_value = [
            {
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                "filepath": "/test/library/dark_300s.xisf",
            }
        ]

        result = find_matching_dark(self.library_dir, self.light_metadata)

        self.assertIsNotNone(result)
        self.assertEqual(result[NORMALIZED_HEADER_EXPOSURESECONDS], "300")

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_find_matching_dark_shorter_exposure(self, mock_get_metadata):
        """Test finding dark with shorter exposure (no exact match)."""
        mock_get_metadata.return_value = [
            {
                NORMALIZED_HEADER_EXPOSURESECONDS: "120",
                "filepath": "/test/library/dark_120s.xisf",
            },
            {
                NORMALIZED_HEADER_EXPOSURESECONDS: "60",
                "filepath": "/test/library/dark_60s.xisf",
            },
        ]

        result = find_matching_dark(self.library_dir, self.light_metadata)

        self.assertIsNotNone(result)
        # Should pick longest dark < 300s (120s)
        self.assertEqual(result[NORMALIZED_HEADER_EXPOSURESECONDS], "120")

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_find_matching_dark_no_match(self, mock_get_metadata):
        """Test when no matching dark found."""
        mock_get_metadata.return_value = []

        result = find_matching_dark(self.library_dir, self.light_metadata)

        self.assertIsNone(result)

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_find_matching_bias(self, mock_get_metadata):
        """Test finding matching bias."""
        mock_get_metadata.return_value = [{"filepath": "/test/library/bias.xisf"}]

        result = find_matching_bias(self.library_dir, self.light_metadata)

        self.assertIsNotNone(result)
        self.assertEqual(result["filepath"], "/test/library/bias.xisf")

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_find_matching_bias_no_match(self, mock_get_metadata):
        """Test when no matching bias found."""
        mock_get_metadata.return_value = []

        result = find_matching_bias(self.library_dir, self.light_metadata)

        self.assertIsNone(result)

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_find_matching_flat(self, mock_get_metadata):
        """Test finding matching flat."""
        mock_get_metadata.return_value = [{"filepath": "/test/library/flat_ha.xisf"}]

        result = find_matching_flat(self.library_dir, self.light_metadata)

        self.assertIsNotNone(result)
        self.assertEqual(result["filepath"], "/test/library/flat_ha.xisf")

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_find_matching_flat_no_match(self, mock_get_metadata):
        """Test when no matching flat found."""
        mock_get_metadata.return_value = []

        result = find_matching_flat(self.library_dir, self.light_metadata)

        self.assertIsNone(result)

    @patch("ap_copy_master_to_blink.matching.find_matching_dark")
    @patch("ap_copy_master_to_blink.matching.find_matching_bias")
    @patch("ap_copy_master_to_blink.matching.find_matching_flat")
    def test_determine_required_masters_exact_dark(
        self, mock_flat, mock_bias, mock_dark
    ):
        """Test determining required masters with exact dark match."""
        mock_dark.return_value = {
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            "filepath": "/test/dark.xisf",
        }
        mock_flat.return_value = {"filepath": "/test/flat.xisf"}

        masters = determine_required_masters(self.library_dir, self.light_metadata)

        self.assertIsNotNone(masters[TYPE_MASTER_DARK])
        self.assertIsNone(
            masters[TYPE_MASTER_BIAS]
        )  # No bias needed for exact exposure match
        self.assertIsNotNone(masters[TYPE_MASTER_FLAT])

    @patch("ap_copy_master_to_blink.matching.find_matching_dark")
    @patch("ap_copy_master_to_blink.matching.find_matching_bias")
    @patch("ap_copy_master_to_blink.matching.find_matching_flat")
    def test_determine_required_masters_shorter_dark_with_bias(
        self, mock_flat, mock_bias, mock_dark
    ):
        """Test determining required masters with shorter dark and bias."""
        mock_dark.return_value = {
            NORMALIZED_HEADER_EXPOSURESECONDS: "120",
            "filepath": "/test/dark.xisf",
        }
        mock_bias.return_value = {"filepath": "/test/bias.xisf"}
        mock_flat.return_value = {"filepath": "/test/flat.xisf"}

        masters = determine_required_masters(self.library_dir, self.light_metadata)

        self.assertIsNotNone(masters[TYPE_MASTER_DARK])
        self.assertIsNotNone(
            masters[TYPE_MASTER_BIAS]
        )  # Bias needed for exposure mismatch
        self.assertIsNotNone(masters[TYPE_MASTER_FLAT])

    @patch("ap_copy_master_to_blink.matching.find_matching_dark")
    @patch("ap_copy_master_to_blink.matching.find_matching_bias")
    @patch("ap_copy_master_to_blink.matching.find_matching_flat")
    def test_determine_required_masters_shorter_dark_no_bias(
        self, mock_flat, mock_bias, mock_dark
    ):
        """Test determining required masters with shorter dark but no bias."""
        mock_dark.return_value = {
            NORMALIZED_HEADER_EXPOSURESECONDS: "120",
            "filepath": "/test/dark.xisf",
        }
        mock_bias.return_value = None  # No bias found
        mock_flat.return_value = {"filepath": "/test/flat.xisf"}

        masters = determine_required_masters(self.library_dir, self.light_metadata)

        # Should reject dark without bias
        self.assertIsNone(masters[TYPE_MASTER_DARK])
        self.assertIsNone(masters[TYPE_MASTER_BIAS])
        self.assertIsNotNone(masters[TYPE_MASTER_FLAT])


class TestFlatDateTolerance(unittest.TestCase):
    """Test flat date tolerance matching logic."""

    def setUp(self):
        """Set up test fixtures."""
        self.library_dir = Path("/test/library")
        self.light_metadata = {
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: "100",
            NORMALIZED_HEADER_OFFSET: "50",
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILTER: "Ha",
            NORMALIZED_HEADER_DATE: "2024-01-15",
            NORMALIZED_HEADER_OPTIC: "RedCat51",
            NORMALIZED_HEADER_FOCALLEN: "250",
        }

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_flat_tolerance_exact_match_preferred(self, mock_get_metadata):
        """Test that exact date match is preferred even with tolerance set."""
        # First call: exact match search (returns exact match)
        # Second call: base criteria search (should not be called)
        mock_get_metadata.return_value = [
            {
                NORMALIZED_HEADER_DATE: "2024-01-15",
                "filepath": "/test/library/flat_exact.xisf",
            }
        ]

        result = find_matching_flat(
            self.library_dir, self.light_metadata, flat_date_tolerance=7
        )

        self.assertIsNotNone(result)
        self.assertEqual(result[NORMALIZED_HEADER_DATE], "2024-01-15")

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_flat_tolerance_older_flat_selected(self, mock_get_metadata):
        """Test that older flat within tolerance is selected when no exact match."""

        def mock_filter(library_dir, filter_criteria):
            if NORMALIZED_HEADER_DATE in filter_criteria:
                # Exact match search - no results
                return []
            else:
                # Base criteria search - return older flats
                return [
                    {
                        NORMALIZED_HEADER_DATE: "2024-01-10",
                        "filepath": "/test/library/flat_older1.xisf",
                    },
                    {
                        NORMALIZED_HEADER_DATE: "2024-01-12",
                        "filepath": "/test/library/flat_older2.xisf",
                    },
                ]

        mock_get_metadata.side_effect = mock_filter

        result = find_matching_flat(
            self.library_dir, self.light_metadata, flat_date_tolerance=7
        )

        self.assertIsNotNone(result)
        # Should select most recent older flat (2024-01-12)
        self.assertEqual(result[NORMALIZED_HEADER_DATE], "2024-01-12")

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_flat_tolerance_newer_flat_when_no_older(self, mock_get_metadata):
        """Test that newer flat is selected when no older flats exist."""

        def mock_filter(library_dir, filter_criteria):
            if NORMALIZED_HEADER_DATE in filter_criteria:
                # Exact match search - no results
                return []
            else:
                # Base criteria search - return only newer flats
                return [
                    {
                        NORMALIZED_HEADER_DATE: "2024-01-18",
                        "filepath": "/test/library/flat_newer1.xisf",
                    },
                    {
                        NORMALIZED_HEADER_DATE: "2024-01-20",
                        "filepath": "/test/library/flat_newer2.xisf",
                    },
                ]

        mock_get_metadata.side_effect = mock_filter

        result = find_matching_flat(
            self.library_dir, self.light_metadata, flat_date_tolerance=7
        )

        self.assertIsNotNone(result)
        # Should select oldest newer flat (2024-01-18)
        self.assertEqual(result[NORMALIZED_HEADER_DATE], "2024-01-18")

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_flat_tolerance_prefers_older_over_newer(self, mock_get_metadata):
        """Test that older flats are preferred over newer flats."""

        def mock_filter(library_dir, filter_criteria):
            if NORMALIZED_HEADER_DATE in filter_criteria:
                # Exact match search - no results
                return []
            else:
                # Base criteria search - return both older and newer flats
                return [
                    {
                        NORMALIZED_HEADER_DATE: "2024-01-10",  # Older (5 days)
                        "filepath": "/test/library/flat_older.xisf",
                    },
                    {
                        NORMALIZED_HEADER_DATE: "2024-01-16",  # Newer (1 day) - closer
                        "filepath": "/test/library/flat_newer.xisf",
                    },
                ]

        mock_get_metadata.side_effect = mock_filter

        result = find_matching_flat(
            self.library_dir, self.light_metadata, flat_date_tolerance=7
        )

        self.assertIsNotNone(result)
        # Should prefer older flat even though newer is closer
        self.assertEqual(result[NORMALIZED_HEADER_DATE], "2024-01-10")

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_flat_tolerance_no_match_outside_tolerance(self, mock_get_metadata):
        """Test that no flat is selected if all are outside tolerance."""

        def mock_filter(library_dir, filter_criteria):
            if NORMALIZED_HEADER_DATE in filter_criteria:
                # Exact match search - no results
                return []
            else:
                # Base criteria search - return flats outside tolerance
                return [
                    {
                        NORMALIZED_HEADER_DATE: "2024-01-01",  # 14 days older
                        "filepath": "/test/library/flat_too_old.xisf",
                    },
                    {
                        NORMALIZED_HEADER_DATE: "2024-01-30",  # 15 days newer
                        "filepath": "/test/library/flat_too_new.xisf",
                    },
                ]

        mock_get_metadata.side_effect = mock_filter

        result = find_matching_flat(
            self.library_dir, self.light_metadata, flat_date_tolerance=7
        )

        self.assertIsNone(result)

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_flat_tolerance_boundary_older(self, mock_get_metadata):
        """Test that flat exactly at older tolerance boundary is included."""

        def mock_filter(library_dir, filter_criteria):
            if NORMALIZED_HEADER_DATE in filter_criteria:
                return []
            else:
                # Flat exactly 7 days older (at boundary)
                return [
                    {
                        NORMALIZED_HEADER_DATE: "2024-01-08",  # Exactly 7 days older
                        "filepath": "/test/library/flat_boundary.xisf",
                    },
                ]

        mock_get_metadata.side_effect = mock_filter

        result = find_matching_flat(
            self.library_dir, self.light_metadata, flat_date_tolerance=7
        )

        self.assertIsNotNone(result)
        self.assertEqual(result[NORMALIZED_HEADER_DATE], "2024-01-08")

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_flat_tolerance_boundary_newer(self, mock_get_metadata):
        """Test that flat exactly at newer tolerance boundary is included."""

        def mock_filter(library_dir, filter_criteria):
            if NORMALIZED_HEADER_DATE in filter_criteria:
                return []
            else:
                # Flat exactly 7 days newer (at boundary)
                return [
                    {
                        NORMALIZED_HEADER_DATE: "2024-01-22",  # Exactly 7 days newer
                        "filepath": "/test/library/flat_boundary.xisf",
                    },
                ]

        mock_get_metadata.side_effect = mock_filter

        result = find_matching_flat(
            self.library_dir, self.light_metadata, flat_date_tolerance=7
        )

        self.assertIsNotNone(result)
        self.assertEqual(result[NORMALIZED_HEADER_DATE], "2024-01-22")

    @patch("ap_copy_master_to_blink.matching.get_filtered_metadata")
    def test_flat_tolerance_zero_no_tolerance(self, mock_get_metadata):
        """Test that tolerance=0 enforces exact match only."""

        def mock_filter(library_dir, filter_criteria):
            if NORMALIZED_HEADER_DATE in filter_criteria:
                # Exact match search - no results
                return []
            else:
                # This should not be called with tolerance=0
                return [
                    {
                        NORMALIZED_HEADER_DATE: "2024-01-14",  # 1 day older
                        "filepath": "/test/library/flat_nearby.xisf",
                    },
                ]

        mock_get_metadata.side_effect = mock_filter

        result = find_matching_flat(
            self.library_dir, self.light_metadata, flat_date_tolerance=0
        )

        self.assertIsNone(result)
        # With tolerance=0, should only call exact match search
        self.assertEqual(mock_get_metadata.call_count, 1)


if __name__ == "__main__":
    unittest.main()
