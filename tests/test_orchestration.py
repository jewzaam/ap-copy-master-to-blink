"""
Tests for orchestration.py module.

Generated By: Claude Code (Claude Sonnet 4.5)
"""

import unittest
from pathlib import Path
from unittest.mock import patch
import tempfile

from ap_copy_master_to_blink.orchestration import process_blink_directory
from ap_copy_master_to_blink import config
from ap_common.constants import (
    NORMALIZED_HEADER_CAMERA,
    NORMALIZED_HEADER_GAIN,
    NORMALIZED_HEADER_OFFSET,
    NORMALIZED_HEADER_SETTEMP,
    NORMALIZED_HEADER_READOUTMODE,
    NORMALIZED_HEADER_EXPOSURESECONDS,
    NORMALIZED_HEADER_FILTER,
    NORMALIZED_HEADER_DATE,
    NORMALIZED_HEADER_FILENAME,
    TYPE_MASTER_DARK,
    TYPE_MASTER_BIAS,
    TYPE_MASTER_FLAT,
)


class TestOrchestration(unittest.TestCase):
    """Test orchestration functions."""

    @patch("ap_copy_master_to_blink.orchestration.scan_blink_directories")
    @patch("ap_copy_master_to_blink.orchestration.determine_required_masters")
    @patch("ap_copy_master_to_blink.orchestration.copy_master_to_blink")
    def test_process_blink_directory_no_lights(
        self, mock_copy, mock_determine, mock_scan
    ):
        """Test processing when no lights found."""
        mock_scan.return_value = []

        stats = process_blink_directory(
            Path("/library"),
            Path("/blink"),
            dry_run=False,
            date_dir_pattern=config.DEFAULT_DATE_DIR_PATTERN,
        )

        self.assertEqual(stats["configs_processed"], 0)
        mock_determine.assert_not_called()
        mock_copy.assert_not_called()

    @patch("ap_copy_master_to_blink.orchestration.scan_blink_directories")
    @patch("ap_copy_master_to_blink.orchestration.group_lights_by_config")
    @patch("ap_copy_master_to_blink.orchestration.determine_required_masters")
    @patch("ap_copy_master_to_blink.orchestration.get_date_directory")
    @patch("ap_copy_master_to_blink.orchestration.check_masters_exist")
    @patch("ap_copy_master_to_blink.orchestration.copy_master_to_blink")
    def test_process_blink_directory_with_all_masters(
        self,
        mock_copy,
        mock_scan_existing,
        mock_get_date,
        mock_determine,
        mock_group,
        mock_scan,
    ):
        """Test processing with all master types found in library."""
        # Mock light metadata
        light_metadata = {
            NORMALIZED_HEADER_FILENAME: (
                "/blink/M31/DATE_2024-01-15" "/FILTER_Ha/light.fits"
            ),
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: "100",
            NORMALIZED_HEADER_OFFSET: "50",
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILTER: "Ha",
            NORMALIZED_HEADER_DATE: "2024-01-15",
        }

        mock_scan.return_value = [light_metadata]
        mock_group.return_value = {("config_key",): [light_metadata]}
        mock_get_date.return_value = Path("/blink/M31/DATE_2024-01-15")

        # Mock no existing masters in blink
        mock_scan_existing.return_value = {
            "has_dark": False,
            "has_bias": False,
            "has_flat": False,
        }

        # Mock all masters found in library
        dark = {NORMALIZED_HEADER_FILENAME: "/library/dark.xisf"}
        bias = {NORMALIZED_HEADER_FILENAME: "/library/bias.xisf"}
        flat = {NORMALIZED_HEADER_FILENAME: "/library/flat.xisf"}
        mock_determine.return_value = {
            TYPE_MASTER_DARK: dark,
            TYPE_MASTER_BIAS: bias,
            TYPE_MASTER_FLAT: flat,
        }

        # Mock successful copy
        mock_copy.return_value = True

        stats = process_blink_directory(
            Path("/library"),
            Path("/blink"),
            dry_run=False,
            date_dir_pattern=config.DEFAULT_DATE_DIR_PATTERN,
        )

        self.assertEqual(stats["frame_count"], 1)
        self.assertEqual(stats["target_count"], 1)
        self.assertEqual(stats["date_count"], 1)
        self.assertEqual(stats["filter_count"], 1)
        self.assertEqual(stats["configs_processed"], 1)
        self.assertEqual(stats["darks_needed"], 1)
        self.assertEqual(stats["darks_present"], 1)
        self.assertEqual(stats["biases_needed"], 1)
        self.assertEqual(stats["biases_present"], 1)
        self.assertEqual(stats["flats_needed"], 1)
        self.assertEqual(stats["flats_present"], 1)

    @patch("ap_copy_master_to_blink.orchestration.scan_blink_directories")
    @patch("ap_copy_master_to_blink.orchestration.group_lights_by_config")
    @patch("ap_copy_master_to_blink.orchestration.determine_required_masters")
    @patch("ap_copy_master_to_blink.orchestration.get_date_directory")
    @patch("ap_copy_master_to_blink.orchestration.check_masters_exist")
    @patch("ap_copy_master_to_blink.orchestration.copy_master_to_blink")
    def test_process_blink_directory_missing_masters(
        self,
        mock_copy,
        mock_scan_existing,
        mock_get_date,
        mock_determine,
        mock_group,
        mock_scan,
    ):
        """Test processing with masters missing from both library and blink."""
        # Mock light metadata
        light_metadata = {
            NORMALIZED_HEADER_FILENAME: (
                "/blink/M31/DATE_2024-01-15" "/FILTER_Ha/light.fits"
            ),
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: "100",
            NORMALIZED_HEADER_OFFSET: "50",
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILTER: "Ha",
            NORMALIZED_HEADER_DATE: "2024-01-15",
        }

        mock_scan.return_value = [light_metadata]
        mock_group.return_value = {("config_key",): [light_metadata]}
        mock_get_date.return_value = Path("/blink/M31/DATE_2024-01-15")

        # Mock no existing masters in blink
        mock_scan_existing.return_value = {
            "has_dark": False,
            "has_bias": False,
            "has_flat": False,
        }

        # Mock no masters found in library
        mock_determine.return_value = {
            TYPE_MASTER_DARK: None,
            TYPE_MASTER_BIAS: None,
            TYPE_MASTER_FLAT: None,
        }

        stats = process_blink_directory(
            Path("/library"),
            Path("/blink"),
            dry_run=False,
            date_dir_pattern=config.DEFAULT_DATE_DIR_PATTERN,
        )

        self.assertEqual(stats["frame_count"], 1)
        self.assertEqual(stats["target_count"], 1)
        self.assertEqual(stats["date_count"], 1)
        self.assertEqual(stats["filter_count"], 1)
        self.assertEqual(stats["configs_processed"], 1)
        self.assertEqual(stats["darks_needed"], 1)
        self.assertEqual(stats["darks_present"], 0)
        self.assertEqual(stats["biases_needed"], 0)
        self.assertEqual(stats["biases_present"], 0)
        self.assertEqual(stats["flats_needed"], 1)
        self.assertEqual(stats["flats_present"], 0)

    @patch("ap_copy_master_to_blink.orchestration.scan_blink_directories")
    @patch("ap_copy_master_to_blink.orchestration.group_lights_by_config")
    @patch("ap_copy_master_to_blink.orchestration.determine_required_masters")
    @patch("ap_copy_master_to_blink.orchestration.get_date_directory")
    @patch("ap_copy_master_to_blink.orchestration.check_masters_exist")
    @patch("ap_copy_master_to_blink.orchestration.copy_master_to_blink")
    def test_process_blink_directory_masters_already_in_blink(
        self,
        mock_copy,
        mock_scan_existing,
        mock_get_date,
        mock_determine,
        mock_group,
        mock_scan,
    ):
        """Test processing when masters exist in blink but not in library."""
        # Mock light metadata
        light_metadata = {
            NORMALIZED_HEADER_FILENAME: (
                "/blink/M31/DATE_2024-01-15" "/FILTER_Ha/light.fits"
            ),
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: "100",
            NORMALIZED_HEADER_OFFSET: "50",
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILTER: "Ha",
            NORMALIZED_HEADER_DATE: "2024-01-15",
        }

        mock_scan.return_value = [light_metadata]
        mock_group.return_value = {("config_key",): [light_metadata]}
        mock_get_date.return_value = Path("/blink/M31/DATE_2024-01-15")

        # Mock masters already exist in blink (e.g., manually copied)
        mock_scan_existing.return_value = {
            "has_dark": True,
            "has_bias": False,
            "has_flat": True,
        }

        # Mock no masters found in library
        mock_determine.return_value = {
            TYPE_MASTER_DARK: None,
            TYPE_MASTER_BIAS: None,
            TYPE_MASTER_FLAT: None,
        }

        stats = process_blink_directory(
            Path("/library"),
            Path("/blink"),
            dry_run=False,
            date_dir_pattern=config.DEFAULT_DATE_DIR_PATTERN,
        )

        self.assertEqual(stats["frame_count"], 1)
        self.assertEqual(stats["configs_processed"], 1)
        self.assertEqual(stats["darks_needed"], 1)
        self.assertEqual(stats["darks_present"], 1)  # Found locally
        self.assertEqual(stats["flats_needed"], 1)
        self.assertEqual(stats["flats_present"], 1)  # Found locally
        # Should not try to copy since they exist locally
        mock_copy.assert_not_called()


class TestIntegration(unittest.TestCase):
    """Integration tests that call real functions without mocking."""

    def test_process_blink_directory_uses_filename_key(self):
        """Test process_blink_directory uses correct 'filename' key.

        Regression test for bug where code used 'filepath' key
        but metadata uses 'filename' (NORMALIZED_HEADER_FILENAME).
        """
        from ap_copy_master_to_blink.orchestration import process_blink_directory

        with tempfile.TemporaryDirectory() as tmpdir:
            library_dir = Path(tmpdir) / "library"
            blink_dir = Path(tmpdir) / "blink"
            library_dir.mkdir()
            blink_dir.mkdir()

            # Create a fake light file (won't be valid FITS but that's okay)
            light_file = blink_dir / "light1.fits"
            light_file.write_text("fake fits")

            # This should not raise KeyError: 'filepath'
            try:
                stats = process_blink_directory(
                    library_dir,
                    blink_dir,
                    dry_run=True,
                    date_dir_pattern=config.DEFAULT_DATE_DIR_PATTERN,
                )
                # We expect missing masters but no KeyError
                self.assertIsInstance(stats, dict)
            except KeyError as e:
                if NORMALIZED_HEADER_FILENAME in str(e):
                    self.fail(f"Code uses 'filepath' instead of 'filename': {e}")
                raise
            except OSError:
                # FITS parsing errors are expected with fake files
                pass


class TestIntegrationOld(unittest.TestCase):
    """Integration tests that call real functions without mocking."""

    @patch("ap_copy_master_to_blink.orchestration.determine_required_masters")
    @patch("ap_copy_master_to_blink.orchestration.check_masters_exist")
    @patch("ap_copy_master_to_blink.orchestration.copy_master_to_blink")
    def test_copies_to_all_target_directories_in_group(
        self, mock_copy_master, mock_scan_existing, mock_determine
    ):
        """Test that masters are copied to ALL target directories with same config.

        Regression test for bug where lights from multiple targets with the same
        calibration config were grouped together, but masters were only copied to
        the first target's directory.
        """
        from ap_copy_master_to_blink.orchestration import process_blink_directory

        # Two targets, both with H filter 300s exposure
        # Should copy masters to BOTH target directories
        mock_scan_data = [
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: "H",
                NORMALIZED_HEADER_DATE: "2026-02-07",
                NORMALIZED_HEADER_FILENAME: (
                    "/blink/Target1/DATE_2026-02-07" "/FILTER_H/light1.xisf"
                ),
            },
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: "H",
                NORMALIZED_HEADER_DATE: "2026-02-07",
                NORMALIZED_HEADER_FILENAME: (
                    "/blink/Target2/DATE_2026-02-07" "/FILTER_H/light2.xisf"
                ),
            },
        ]

        from ap_common.constants import (
            TYPE_MASTER_DARK,
            TYPE_MASTER_BIAS,
            TYPE_MASTER_FLAT,
        )

        mock_masters = {
            TYPE_MASTER_DARK: {NORMALIZED_HEADER_FILENAME: "/library/dark.xisf"},
            TYPE_MASTER_BIAS: None,
            TYPE_MASTER_FLAT: {NORMALIZED_HEADER_FILENAME: "/library/flat.xisf"},
        }
        mock_determine.return_value = mock_masters
        mock_copy_master.return_value = True

        # Mock no existing masters in blink
        mock_scan_existing.return_value = {
            "has_dark": False,
            "has_bias": False,
            "has_flat": False,
        }

        with patch(
            "ap_copy_master_to_blink.orchestration.scan_blink_directories",
            return_value=mock_scan_data,
        ):
            process_blink_directory(
                Path("/library"),
                Path("/blink"),
                config.DEFAULT_DATE_DIR_PATTERN,
                dry_run=False,
            )

        # Should have called copy_master_to_blink for both directories
        # 2 targets * 2 masters (dark + flat) = 4 copies
        self.assertEqual(mock_copy_master.call_count, 4)

        # Verify it was called with both target directories
        # Normalize paths to use forward slashes for comparison
        called_dirs = {
            str(call[0][1]).replace("\\", "/")
            for call in mock_copy_master.call_args_list
        }
        self.assertIn("/blink/Target1/DATE_2026-02-07", called_dirs)
        self.assertIn("/blink/Target2/DATE_2026-02-07", called_dirs)

    @patch("ap_copy_master_to_blink.matching.find_darks_util")
    def test_get_filtered_metadata_returns_dict(self, mock_find_darks):
        """Test that find_matching_dark handles list return from utility.

        Regression test - updated for new utility-based implementation.
        """
        from ap_copy_master_to_blink.matching import find_matching_dark
        from ap_common.constants import (
            NORMALIZED_HEADER_EXPOSURESECONDS,
            NORMALIZED_HEADER_FILENAME,
        )

        # Utility returns list of metadata dicts (sorted by exposure, longest first)
        mock_find_darks.return_value = [
            {
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILENAME: "/test/dark1.xisf",
            },
            {
                NORMALIZED_HEADER_EXPOSURESECONDS: "120",
                NORMALIZED_HEADER_FILENAME: "/test/dark2.xisf",
            },
        ]

        light_metadata = {
            "camera": "TestCamera",
            "gain": "100",
            "offset": "50",
            "settemp": "-10.00",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
        }

        # Should return first match (exact exposure match)
        result = find_matching_dark(Path("/test/library"), light_metadata)
        self.assertIsNotNone(result)
        self.assertEqual(result[NORMALIZED_HEADER_EXPOSURESECONDS], "300")

    def test_find_matching_dark_integration(self):
        """Test find_matching_dark with real get_filtered_metadata call.

        Regression test for bug where get_filtered_metadata was called
        with only (library_dir, filter_criteria) but requires profileFromPath.
        """
        from ap_copy_master_to_blink.matching import find_matching_dark

        with tempfile.TemporaryDirectory() as tmpdir:
            library_dir = Path(tmpdir) / "library"
            library_dir.mkdir()

            light_metadata = {
                NORMALIZED_HEADER_CAMERA: "TestCam",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "10",
                NORMALIZED_HEADER_SETTEMP: "-10.00",
                NORMALIZED_HEADER_READOUTMODE: "HighGain",
                NORMALIZED_HEADER_EXPOSURESECONDS: "60.00",
            }

            # This should not raise TypeError about missing profileFromPath
            try:
                result = find_matching_dark(library_dir, light_metadata)
                # We expect None because no masters exist in empty directory
                self.assertIsNone(result)
            except TypeError as e:
                if "profileFromPath" in str(e):
                    self.fail(f"get_filtered_metadata() API mismatch: {e}")
                raise

    def test_find_matching_dark_with_missing_metadata(self):
        """Test find_matching_dark handles missing metadata fields.

        Tests that matching works with empty string (normalized from None).
        """
        from ap_copy_master_to_blink.matching import find_matching_dark

        with tempfile.TemporaryDirectory() as tmpdir:
            library_dir = Path(tmpdir) / "library"
            library_dir.mkdir()

            # Light metadata with missing readoutmode (normalized to empty string)
            light_metadata = {
                NORMALIZED_HEADER_CAMERA: "TestCam",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "10",
                NORMALIZED_HEADER_SETTEMP: "-10.00",
                NORMALIZED_HEADER_READOUTMODE: "",  # Normalized from None
                NORMALIZED_HEADER_EXPOSURESECONDS: "60.00",
            }

            result = find_matching_dark(library_dir, light_metadata)
            # We expect None because no masters exist
            self.assertIsNone(result)

    def test_validate_directories_integration(self):
        """Test validate_directories requires Path objects, not strings.

        Regression test for bug where resolve_path returns string
        but validate_directories expected Path objects. The fix was to
        wrap resolve_path results with Path() in main().
        """
        from ap_copy_master_to_blink.__main__ import validate_directories

        with tempfile.TemporaryDirectory() as tmpdir:
            library_dir = Path(tmpdir) / "library"
            blink_dir = Path(tmpdir) / "blink"
            library_dir.mkdir()
            blink_dir.mkdir()

            # validate_directories should work with Path objects
            is_valid, error = validate_directories(library_dir, blink_dir)
            self.assertTrue(is_valid)
            self.assertIsNone(error)

            # validate_directories should NOT work with strings (by design)
            # main() must wrap resolve_path() results with Path()
            with self.assertRaises(AttributeError):
                validate_directories(str(library_dir), str(blink_dir))


class TestFlexibleFlatMatching(unittest.TestCase):
    """Tests for flexible flat matching integration in process_blink_directory."""

    @patch("ap_copy_master_to_blink.orchestration.scan_blink_directories")
    @patch("ap_copy_master_to_blink.orchestration.determine_required_masters")
    @patch("ap_copy_master_to_blink.orchestration.check_masters_exist")
    @patch("ap_copy_master_to_blink.orchestration.copy_master_to_blink")
    @patch("ap_copy_master_to_blink.flat_batch_selection.find_candidate_flat_dates")
    @patch("ap_copy_master_to_blink.flat_batch_selection.pick_flat_date")
    @patch("ap_copy_master_to_blink.flat_batch_selection.find_flat_for_date")
    @patch("ap_copy_master_to_blink.orchestration.find_flat_for_date")
    @patch("ap_copy_master_to_blink.orchestration.load_state")
    @patch("ap_copy_master_to_blink.orchestration.save_state")
    def test_flexible_flat_fallback_user_selects_date(
        self,
        mock_save_state,
        mock_load_state,
        mock_find_flat_for_date_orch,
        mock_find_flat_for_date_batch,
        mock_pick,
        mock_candidates,
        mock_copy,
        mock_check,
        mock_determine,
        mock_scan,
    ):
        """When no exact flat, user selects from picker, flat is used."""
        from datetime import date

        light_metadata = {
            NORMALIZED_HEADER_FILENAME: (
                "/blink/M31/DATE_2024-01-15/FILTER_Ha/light.fits"
            ),
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: "100",
            NORMALIZED_HEADER_OFFSET: "50",
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILTER: "Ha",
            NORMALIZED_HEADER_DATE: "2024-01-15",
        }

        mock_scan.return_value = [light_metadata]
        mock_load_state.return_value = {}

        # No exact flat match
        mock_determine.return_value = {
            TYPE_MASTER_DARK: {
                NORMALIZED_HEADER_FILENAME: "/lib/dark.xisf",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            },
            TYPE_MASTER_BIAS: None,
            TYPE_MASTER_FLAT: None,
        }

        # Candidate dates available
        mock_candidates.return_value = {
            "2024-01-10": {NORMALIZED_HEADER_FILENAME: "/lib/flat_10.xisf"},
        }

        # User picks older date
        mock_pick.return_value = date(2024, 1, 10)

        # Flat found for selected date
        flat_for_date = {
            NORMALIZED_HEADER_FILENAME: "/lib/flat_10.xisf",
            NORMALIZED_HEADER_DATE: "2024-01-10",
        }
        mock_find_flat_for_date_batch.return_value = flat_for_date
        mock_find_flat_for_date_orch.return_value = flat_for_date

        mock_check.return_value = {
            "has_dark": False,
            "has_bias": False,
            "has_flat": False,
        }
        mock_copy.return_value = True

        with tempfile.NamedTemporaryFile(suffix=".yaml") as f:
            stats = process_blink_directory(
                Path("/library"),
                Path("/blink"),
                dry_run=False,
                flat_state_path=Path(f.name),
                date_dir_pattern=config.DEFAULT_DATE_DIR_PATTERN,
            )

        # Flat should have been found via fallback
        self.assertEqual(stats["flats_present"], 1)
        self.assertEqual(stats["flats_needed"], 1)

    @patch("ap_copy_master_to_blink.orchestration.scan_blink_directories")
    @patch("ap_copy_master_to_blink.orchestration.determine_required_masters")
    @patch("ap_copy_master_to_blink.orchestration.check_masters_exist")
    @patch("ap_copy_master_to_blink.orchestration.copy_master_to_blink")
    @patch("ap_copy_master_to_blink.orchestration.load_state")
    @patch("ap_copy_master_to_blink.orchestration.save_state")
    def test_exact_match_updates_state_cutoff(
        self,
        mock_save_state,
        mock_load_state,
        mock_copy,
        mock_check,
        mock_determine,
        mock_scan,
    ):
        """Exact flat match updates the state cutoff."""
        light_metadata = {
            NORMALIZED_HEADER_FILENAME: (
                "/blink/M31/DATE_2024-01-15/FILTER_Ha/light.fits"
            ),
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: "100",
            NORMALIZED_HEADER_OFFSET: "50",
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILTER: "Ha",
            NORMALIZED_HEADER_DATE: "2024-01-15",
        }

        mock_scan.return_value = [light_metadata]
        state = {}
        mock_load_state.return_value = state

        # Exact flat match found
        mock_determine.return_value = {
            TYPE_MASTER_DARK: {
                NORMALIZED_HEADER_FILENAME: "/lib/dark.xisf",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            },
            TYPE_MASTER_BIAS: None,
            TYPE_MASTER_FLAT: {NORMALIZED_HEADER_FILENAME: "/lib/flat.xisf"},
        }

        mock_check.return_value = {
            "has_dark": False,
            "has_bias": False,
            "has_flat": False,
        }
        mock_copy.return_value = True

        with tempfile.NamedTemporaryFile(suffix=".yaml") as f:
            process_blink_directory(
                Path("/library"),
                Path("/blink"),
                dry_run=False,
                flat_state_path=Path(f.name),
                date_dir_pattern=config.DEFAULT_DATE_DIR_PATTERN,
            )

        # State should have been saved
        mock_save_state.assert_called_once()
        # State should include the blink dir with cutoff
        saved_state = mock_save_state.call_args[0][1]
        self.assertIn(str(Path("/blink")), saved_state)

    @patch("ap_copy_master_to_blink.orchestration.scan_blink_directories")
    @patch("ap_copy_master_to_blink.orchestration.determine_required_masters")
    @patch("ap_copy_master_to_blink.orchestration.check_masters_exist")
    @patch("ap_copy_master_to_blink.orchestration.copy_master_to_blink")
    @patch("ap_copy_master_to_blink.orchestration.load_state")
    @patch("ap_copy_master_to_blink.orchestration.save_state")
    def test_dry_run_does_not_save_state(
        self,
        mock_save_state,
        mock_load_state,
        mock_copy,
        mock_check,
        mock_determine,
        mock_scan,
    ):
        """Dry run does not save the state file."""
        light_metadata = {
            NORMALIZED_HEADER_FILENAME: (
                "/blink/M31/DATE_2024-01-15/FILTER_Ha/light.fits"
            ),
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: "100",
            NORMALIZED_HEADER_OFFSET: "50",
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILTER: "Ha",
            NORMALIZED_HEADER_DATE: "2024-01-15",
        }

        mock_scan.return_value = [light_metadata]
        mock_load_state.return_value = {}

        mock_determine.return_value = {
            TYPE_MASTER_DARK: {
                NORMALIZED_HEADER_FILENAME: "/lib/dark.xisf",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            },
            TYPE_MASTER_BIAS: None,
            TYPE_MASTER_FLAT: {NORMALIZED_HEADER_FILENAME: "/lib/flat.xisf"},
        }

        mock_check.return_value = {
            "has_dark": False,
            "has_bias": False,
            "has_flat": False,
        }
        mock_copy.return_value = True

        with tempfile.NamedTemporaryFile(suffix=".yaml") as f:
            process_blink_directory(
                Path("/library"),
                Path("/blink"),
                dry_run=True,
                flat_state_path=Path(f.name),
                date_dir_pattern=config.DEFAULT_DATE_DIR_PATTERN,
            )

        # State should NOT have been saved during dry run
        mock_save_state.assert_not_called()

    @patch("ap_copy_master_to_blink.orchestration.scan_blink_directories")
    @patch("ap_copy_master_to_blink.orchestration.determine_required_masters")
    @patch("ap_copy_master_to_blink.orchestration.check_masters_exist")
    @patch("ap_copy_master_to_blink.orchestration.copy_master_to_blink")
    def test_no_flat_state_path_skips_flexible_matching(
        self,
        mock_copy,
        mock_check,
        mock_determine,
        mock_scan,
    ):
        """Without --flat-state, no flexible matching occurs."""
        light_metadata = {
            NORMALIZED_HEADER_FILENAME: (
                "/blink/M31/DATE_2024-01-15/FILTER_Ha/light.fits"
            ),
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: "100",
            NORMALIZED_HEADER_OFFSET: "50",
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILTER: "Ha",
            NORMALIZED_HEADER_DATE: "2024-01-15",
        }

        mock_scan.return_value = [light_metadata]

        # No flat match
        mock_determine.return_value = {
            TYPE_MASTER_DARK: {
                NORMALIZED_HEADER_FILENAME: "/lib/dark.xisf",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            },
            TYPE_MASTER_BIAS: None,
            TYPE_MASTER_FLAT: None,
        }

        mock_check.return_value = {
            "has_dark": False,
            "has_bias": False,
            "has_flat": False,
        }
        mock_copy.return_value = True

        # No flat_state_path - should not trigger flexible matching
        stats = process_blink_directory(
            Path("/library"),
            Path("/blink"),
            dry_run=False,
            date_dir_pattern=config.DEFAULT_DATE_DIR_PATTERN,
        )

        # Flat should be missing
        self.assertEqual(stats["flats_present"], 0)
        self.assertEqual(stats["flats_needed"], 1)

    @patch("ap_copy_master_to_blink.orchestration.scan_blink_directories")
    @patch("ap_copy_master_to_blink.orchestration.determine_required_masters")
    @patch("ap_copy_master_to_blink.orchestration.check_masters_exist")
    @patch("ap_copy_master_to_blink.orchestration.copy_master_to_blink")
    @patch("ap_copy_master_to_blink.flat_batch_selection.find_candidate_flat_dates")
    @patch("ap_copy_master_to_blink.orchestration.load_state")
    @patch("ap_copy_master_to_blink.orchestration.save_state")
    def test_quiet_mode_skips_picker(
        self,
        mock_save_state,
        mock_load_state,
        mock_candidates,
        mock_copy,
        mock_check,
        mock_determine,
        mock_scan,
    ):
        """Quiet mode skips interactive picker, treats as missing."""
        light_metadata = {
            NORMALIZED_HEADER_FILENAME: (
                "/blink/M31/DATE_2024-01-15/FILTER_Ha/light.fits"
            ),
            NORMALIZED_HEADER_CAMERA: "ASI2600MM",
            NORMALIZED_HEADER_GAIN: "100",
            NORMALIZED_HEADER_OFFSET: "50",
            NORMALIZED_HEADER_SETTEMP: "-10",
            NORMALIZED_HEADER_READOUTMODE: "0",
            NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            NORMALIZED_HEADER_FILTER: "Ha",
            NORMALIZED_HEADER_DATE: "2024-01-15",
        }

        mock_scan.return_value = [light_metadata]
        mock_load_state.return_value = {}

        mock_determine.return_value = {
            TYPE_MASTER_DARK: {
                NORMALIZED_HEADER_FILENAME: "/lib/dark.xisf",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
            },
            TYPE_MASTER_BIAS: None,
            TYPE_MASTER_FLAT: None,
        }

        mock_check.return_value = {
            "has_dark": False,
            "has_bias": False,
            "has_flat": False,
        }
        mock_copy.return_value = True

        with tempfile.NamedTemporaryFile(suffix=".yaml") as f:
            stats = process_blink_directory(
                Path("/library"),
                Path("/blink"),
                dry_run=False,
                quiet=True,
                flat_state_path=Path(f.name),
                date_dir_pattern=config.DEFAULT_DATE_DIR_PATTERN,
            )

        # Should NOT have called find_candidate_flat_dates in quiet mode
        mock_candidates.assert_not_called()
        # Flat should be missing
        self.assertEqual(stats["flats_present"], 0)


if __name__ == "__main__":
    unittest.main()
