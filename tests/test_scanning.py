"""
Tests for scanning.py module.

Generated By: Claude Code (Claude Sonnet 4.5)
"""

import unittest
from pathlib import Path
from unittest.mock import patch
import tempfile

from ap_copy_master_to_blink.scanning import (
    scan_blink_directories,
    group_lights_by_config,
    sort_groups_by_date,
)
from ap_common.constants import (
    NORMALIZED_HEADER_CAMERA,
    NORMALIZED_HEADER_GAIN,
    NORMALIZED_HEADER_OFFSET,
    NORMALIZED_HEADER_SETTEMP,
    NORMALIZED_HEADER_READOUTMODE,
    NORMALIZED_HEADER_EXPOSURESECONDS,
    NORMALIZED_HEADER_FILTER,
    NORMALIZED_HEADER_DATE,
    NORMALIZED_HEADER_FILENAME,
)


class TestScanning(unittest.TestCase):
    """Test scanning functions."""

    @patch("ap_copy_master_to_blink.scanning.get_filtered_metadata")
    def test_scan_blink_directories(self, mock_get_filtered_metadata):
        """Test scanning blink directories for light frames."""
        # get_filtered_metadata returns a dict of {filename: metadata}
        mock_get_filtered_metadata.return_value = {
            "/blink/light1.fits": {NORMALIZED_HEADER_FILENAME: "/blink/light1.fits"},
            "/blink/light2.fits": {NORMALIZED_HEADER_FILENAME: "/blink/light2.fits"},
        }

        result = scan_blink_directories(Path("/blink"))

        self.assertEqual(len(result), 2)
        mock_get_filtered_metadata.assert_called_once()

    def test_group_lights_by_config(self):
        """Test grouping lights by calibration configuration."""
        metadata_list = [
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: "Ha",
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: "Ha",
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: "OIII",  # Different filter
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
        ]

        groups = group_lights_by_config(metadata_list)

        # Should have 2 groups (Ha and OIII)
        self.assertEqual(len(groups), 2)

        # Ha group should have 2 lights
        ha_groups = [g for g in groups.values() if len(g) == 2]
        self.assertEqual(len(ha_groups), 1)

        # OIII group should have 1 light
        oiii_groups = [g for g in groups.values() if len(g) == 1]
        self.assertEqual(len(oiii_groups), 1)

    def test_group_lights_by_config_none_filter_normalization(self):
        """Test that None filter values are normalized to empty string for grouping."""
        metadata_list = [
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: None,  # No filter
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: None,  # No filter
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: "100",
                NORMALIZED_HEADER_OFFSET: "50",
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: "Ha",  # Different filter
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
        ]

        groups = group_lights_by_config(metadata_list)

        # Should have 2 groups (None normalized to "" and "Ha")
        self.assertEqual(len(groups), 2)

        # None filter group should have 2 lights
        none_filter_groups = [g for g in groups.values() if len(g) == 2]
        self.assertEqual(len(none_filter_groups), 1)

        # Ha filter group should have 1 light
        ha_filter_groups = [g for g in groups.values() if len(g) == 1]
        self.assertEqual(len(ha_filter_groups), 1)

    def test_group_lights_by_config_multiple_none_values(self):
        """Test that multiple None values in different fields are normalized."""
        metadata_list = [
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: None,  # None value
                NORMALIZED_HEADER_OFFSET: None,  # None value
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: None,  # None value
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
            {
                NORMALIZED_HEADER_CAMERA: "ASI2600MM",
                NORMALIZED_HEADER_GAIN: None,  # None value
                NORMALIZED_HEADER_OFFSET: None,  # None value
                NORMALIZED_HEADER_SETTEMP: "-10",
                NORMALIZED_HEADER_READOUTMODE: "0",
                NORMALIZED_HEADER_EXPOSURESECONDS: "300",
                NORMALIZED_HEADER_FILTER: None,  # None value
                NORMALIZED_HEADER_DATE: "2024-01-15",
            },
        ]

        groups = group_lights_by_config(metadata_list)

        # Should have 1 group (all None values normalized to "")
        self.assertEqual(len(groups), 1)

        # Group should contain both lights
        single_group = list(groups.values())[0]
        self.assertEqual(len(single_group), 2)

    def test_scan_blink_directories_integration(self):
        """Test scan_blink_directories with real get_filenames call.

        This integration test ensures the function signature matches between
        scan_blink_directories and get_filenames from ap-common.

        Regression test for bugs where:
        1. get_filenames was called with extensions= parameter (doesn't exist)
        2. blink_dir was passed as string instead of list to get_filenames
        """
        # Create temporary directory structure
        with tempfile.TemporaryDirectory() as tmpdir:
            blink_dir = Path(tmpdir) / "blink"
            blink_dir.mkdir()

            # Create some test files
            (blink_dir / "light1.fits").write_text("fake fits data")
            (blink_dir / "light2.xisf").write_text("fake xisf data")
            (blink_dir / "ignore.txt").write_text("should be ignored")

            # Should not raise TypeError about unexpected
            # keyword argument 'extensions' or AttributeError
            # about string not having certain attributes
            try:
                result = scan_blink_directories(blink_dir)
                # We expect empty list because files don't have valid metadata
                # but the function should execute without parameter errors
                self.assertIsInstance(result, list)
            except TypeError as e:
                if "extensions" in str(e) or "got an unexpected keyword" in str(e):
                    self.fail(f"API mismatch: {e}")
                raise
            except OSError as e:
                # FITS parsing may fail - we're testing
                # API compatibility, not FITS parsing
                if "SIMPLE card" not in str(e):
                    raise


class TestSortGroupsByDate(unittest.TestCase):
    """Tests for _sort_groups_by_date function."""

    def test_sort_ascending(self):
        """Groups are sorted by date ascending (oldest first)."""
        groups = {
            ("cam", "100", "50", "-10", "0", "300", "Ha", "2024-03-01"): [
                {"metadata": "march"}
            ],
            ("cam", "100", "50", "-10", "0", "300", "Ha", "2024-01-01"): [
                {"metadata": "jan"}
            ],
            ("cam", "100", "50", "-10", "0", "300", "Ha", "2024-02-01"): [
                {"metadata": "feb"}
            ],
        }

        sorted_groups = sort_groups_by_date(groups)
        dates = [item[0][7] for item in sorted_groups]

        self.assertEqual(dates, ["2024-01-01", "2024-02-01", "2024-03-01"])

    def test_sort_with_none_date(self):
        """Groups with None date sort before dated groups."""
        groups = {
            ("cam", "100", "50", "-10", "0", "300", "Ha", "2024-01-01"): [
                {"metadata": "jan"}
            ],
            ("cam", "100", "50", "-10", "0", "300", "Ha", None): [{"metadata": "none"}],
        }

        sorted_groups = sort_groups_by_date(groups)
        dates = [item[0][7] for item in sorted_groups]

        # None sorts as "" which comes before any date string
        self.assertEqual(dates, [None, "2024-01-01"])

    def test_sort_preserves_all_groups(self):
        """All groups are preserved after sorting."""
        groups = {
            ("cam", "100", "50", "-10", "0", "300", "Ha", "2024-01-01"): [{"m": "1"}],
            ("cam", "100", "50", "-10", "0", "300", "OIII", "2024-01-01"): [{"m": "2"}],
        }

        sorted_groups = sort_groups_by_date(groups)
        self.assertEqual(len(sorted_groups), 2)


if __name__ == "__main__":
    unittest.main()
